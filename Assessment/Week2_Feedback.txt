Starting weekly assessment for Emma, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 7.43 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Assessment, week3, Week2, .git

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~
*.tmp
*.bbl
*.blg
*.pdf
*.aux
*.log
__pycache__
.DS_Store
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
CMEE Coursework Repository- readme.txt 

Files included: 
Week1: Learnt Unix and Shell scripting 

    Code 
        boilerplate.sh      tabtocsv.sh        variables.sh       MyExampleScript.sh 
        CountLines.sh       ConcatenateTwoFiles.sh                tiff2png.sh
        csvtospace.sh       UnixPrac1.txt
    Data
        407228326.fasta     407228412.fasta    E.coli.fasta        spawannxs.txt
        Temperature:    
                    1800.csv    1801.csv       1802.csv         1803.csv 
    Sandbox 
        test.txt        test.txt.csv        ListRootDir.txt
        TestWild



File functions: 
Week1 
    Code
        boilerplate.sh: 
            Function: Shell script that recites 'This is a shell script!' when run

        tabtocsv.sh: Shell script to substitute all tabs with commas. 
            Input: File for the script to be run on
            Output: File with commas instead of tabs 

        variables.sh: Shell script to show the use of variables. 
            Input: 1 string and two variables. 
            Output: Value of string and adds the two variables together  

        MyExampleScript.sh: Bash script that outputs 'Hello' and the Username of the user twice when run. 

        CountLines: Bash script that counts the number of lines in a file. 
            Input: File directory 

        ConcatenateTwoFiles: Bash script that concatenates the contents of two files. 
            Input: Var1 Var2; Two file paths to be merged and Var3; file to be merged to  

        tiff2png.sh: Bash script that converts a tiff file to a png
                     ********* Need to have installed imagemagick on unix system. ************
            Input: tiff file
            Output: png file

        csvtospace.sh: Takes comma seperated values and converts it to space seperated values whilst not changing the input file. 
            Input: csv datafile    
            Output: Seperate file saved under different name 
                        
        UnixPrac1.txt: The first practical submission of the CMEE Course Work covering the chapter in UNIX 
            Input: fasta files  
            Output: How many lines in each fasta file
                    Prints everything in E.coli.fasta file except first lines
                    Count the sequence length of genome in fasta file 
                    Count matches of "ATGC" in genome 
                    AT/GC ratio of E.coli.fasta file
        
        FirstExample.tex: Latex file template 
        
        FirstBiblio.bib: The bibliography of a paper 

        CompileLaTeX.sh: Compiles latex with bibtex
            Input: File that needs to be compiled with bibtex
        
    Data
    407228326.fasta: Input file for fasta exercise    
    407228412.fasta: Input file for fasta exercise 
    E.coli.fasta: Input file for fasta exercise 
    Temperatures: Input files for the shell scripting excercises 
                1800.csv
                1801.csv
                1802.csv
                1803.csv
    spawannxs.txt: Input files for practice excercises in Unix and shell scripting 

    Sandbox: A practice directory for work practice.


# list every directory and what it did and whats in 
# e.g. week 1: bash shel, wek 2: ... 

#list all code files that are in the directories and what they do 
#need to know whats in and whats - languages, packages ( VERSIONS) 
#user guide- no other context 
#this week you;; need this stuff you need etc 
#inputs **********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week1, Week2, week3

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox, results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
CMEE Coursework Repository- readme.txt 

Week2 focuses on the basics of Python; Topics covered include:
    - Basics of python syntax and data structures
    - Python's object-oriented features
    - How to write and run python code
    - Understand and implement python control flow tools
    - Learning to use the ipython environment 
    - Writing, debugging, using, and testing python functions 
    - Learning efficient numerical programming in python
    - Using regular expressions in python
    - Introduction to certain particularly useful python packages
    - Using python for building and modifying databases
    - Using python to run other, non-python tasks and code
    - Using python to patch together data analysis and/or numerical        simulation work flows

Files included:
Week2 
    Code 
        align_seqs.py           align_seqs_better.py    boilerplate.py 
        align_seqs_fasta.py     debugme.py              test_control_flow.py
        basic_csv.py            dictionary.py           loops.py  test_control_flow.pyc   basic_io3.py            oaks.py
        basic_io1.py            lc1.py                  tuple.py
        basic_io2.py            lc2.py                  using_name.py
        cfexercises1.py         cfexercises2.py         oaks_debugme.py
        control_flow.py         scope.py                sysargv.py
    Data
        407228326.fasta         407228412.fasta         TestOaksData.csv
        testcsv.csv             bodymass.csv            sequences.csv
         
    results



File functions: 

Week2 
    Code
        basic_io1.py: 
            Function: Returns the contents of 'test.txt' in different formats e.g. excludes second lines

        basic_io2.py: 
            Function: Saves the elements of a list to a file and adds a new line when saving  

        basic_io3.py: 
            Function: Uses pickle to store an object from a dictionary before loading data again 
            ******** Requires import of pickle *********  

        basic_csv.py: 
            Function: Reads in the testcsv.csv file containing phylogeny information and appends a tuple with the name of a species. 
            Writes a seperate file containing only species name and body mass
            ******** Requires import csv *********

        loops.py:  
            Function: A series of for and while loops 

        cfexercises2.py:
            Function: A series of conditionals containing for and while loops 

        oaks.py: 
            Function: A example exercise using for loops and list comprehensions to find taxa that are oak trees from a list of species. 
                        
        scope.py: 
            Function: A collection of three blocks of code illustrating variable scope.
            
        boilerplate.py: 
            Function: Example exercise on writing python programmes. Purpose of example programme is to print 'This is a boilerplate'). Illustrates how programmes are laid out and uses of "main" arguments as well as docstrings.
            ******* Requires import sys ****** 
        
        using_name.py: 
            Function: An if else statement within a python programme printing whether the programme is being imported from another module of being run by itself. 

        sysargv.py: 
            Function: Exercise of the sys.argv module which contains the names of the argument variables in the current script. 
            ***** Requires import sys *******

        control_flow.py: 
            Function: Similar to boilerplate.py in structure as its a python programme but adds docstrings and a series of functions 
            ****** Requires import sys *******

        lc1.py: PRACTICAL 1 PART 1 
            Function: Uses list comprehensions and for loops to create three lists containing latin names, common names and mean body masses for each species of birds in a given list of birds
        
        lc2.py: PRACTICAL 1 PART 2
            Function: Uses list comprehensions and for loops to create list of month, rainfall tuples when the amount of rain was; Greater than 100mm and Less than 50mm from a list of rainfall averages 

        dictionary.py: PRACTICAL 1 PART 3
            Function: Populates a dictionary to map order names to sets of taxa

        tuple.py: PRACTICAL 1 PART 4
            Function: Prints the latin name, common name and mass of a list of birds on seperate lines

        cfexercises1.py: PRACTICAL 2
            Function: Conditionals exercise containing 6 different foo_x calculation functions. Later modified to make a module that tests the foo_x functions as well as runs test arguments 

        test_control_flow.py: 
            Function: Function exemplifying the use of control elements

        align_seqs.py: PRACTICAL 3 PART 1
            Function: Converts the initial 'align_seqs.py' script to a pprogramme that takes DNA sequences as an input from a single external file and saves the best alignment along with the score into a text file. 
            Input: None 
            Output: Text file with best aligment 
            ******* Requires import sys *********

        align_seqs_fasta.py: PRACTICAL 3 PART 2
            Function: Same basic script as 'align_seqs.py' but aligns fasta files. option to manually input fasta files to be aligned or to have a default where there are no inputs. 
            Inputs: Optional. Two fasta files 
            Outputs: Text file with best aligment 
            ******* Requires import sys and os *********

        align_seqs_better.py: PRACTICAL 3 PART 3
            Function: Runs alignments on files and inputs the highest alignments into a single text file as oppose to one the last highest alignment the programme finds. 
            Inputs: Optional. Two fasta files 
            Outputs: Text file with the highest alignments and their associated scores
            ******* Requires import sys and os *********

        oaks_debugme.py PRACTICAL 4 PART 1
            Function: A script with a bug that was corrected with debugging. Takes as input a file with tree species and returns a file with only oak species found.
            Note: must enter species name exactly. 
            Input: File with species 
            Output: Text file with only oak species. 
            ********* Requires import of csv, sys, doctest and re *********

        
    Data
    407228326.fasta: Input file for fasta exercise of align_seq practical   
    407228412.fasta: Input file for fasta exercise of align_seq practical
    TestOaksData.csv: Input file for oaks_debugme.py practical 
    sequences.csv: Input file for align_seqs practical part 2
    bodymass.csv: Test file for practicals
    testcsv.csv: Test input file for csv practical **********************************************************************

Found following files in results directory: JustOaksData.csv, best_fasta_alignment.txt, improved_fasta_alignment.txt, best_alignment.txt...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 23 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, align_seqs_better.py, dictionary.py, debugme.py, scope.py, basic_io3.py, cfexercises1.py, tuple.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, basic_io2.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py, basic_io1.py

Found the following extra files: 
0.5 pt deducted per extra file

Current Points = 100.0

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

""" Uses list comprehensions and for loops to create list of month, rainfall tuples when the
amount of rain was: 
Greater than 100mm 
Less than 50mm """

#List comprehension that returns months of rainfall when it was over or 
# equal to 100mm
x = set([i for i in rainfall if (i[1]) >= 100])
print(x)

# List comprehension that returns months of rainfall when it was under 50mm
x = set([i for i in rainfall if (i[1]) <= 50])
print(x)

# For loop that returns months of rainfall when it was over or 
# equal to 100mm
List_of_rain = []
for w in rainfall:
    if (w[1]) >= 100:
        List_of_rain.append(w)
print(List_of_rain)

# For loop that returns months of rainfall when it was under 50mm
List_of_rain = []
for w in rainfall:
    if (w[1]) <= 50:
        List_of_rain.append(w)
for a in List_of_rain:
    print(a)**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{('JAN', 111.4), ('NOV', 128.4), ('AUG', 140.2), ('FEB', 126.1), ('DEC', 142.2)}
{('SEP', 27.0), ('MAR', 49.9)}
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
('MAR', 49.9)
('SEP', 27.0)

**********************************************************************

Code ran without errors

Time consumed = 0.04160s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 

"""Description of this program or application. You can use several lines"""

__appname__ = '[boilerplate]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__licence__ = "License for this code/program"

## imports ##
import sys # Module to interface our program with the operating system 

## constants ##


## functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.03363s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
f = open('../Data/testcsv.csv','r')

csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
    print(row)
    print("The species is", row[0])

f.close()

# write a file containing only species name and Body mass
f = open('../Data/testcsv.csv','r')
g = open('../Data/bodymass.csv','w')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
    print(row)
    csvwrite.writerow([row[0], row[4]])

f.close()
g.close()**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 99.0

Output (only first 500 characters): 

**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.02954s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#for j in range of 12 dont print every 3 
for j in range(12):
    if j % 3 == 0: 
        print('hello')

for j in range(15):
    if j % 5 == 3:
        print('hello')
    elif j % 4 == 3:
        print('hello')

#Whilst z is not equal to 15 print hello in incredments of 3 
z = 0
while z != 15: 
    print('hello')
    z = z + 3


z = 12 
while z < 100:
    if z == 31:
        for k in range(7): 
            print('hello')
    elif z == 18: 
        print('hello')
    z = z + 1**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 98.0

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.02876s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:
**********************************************************************

#!/usr/bin/env python3

"""This programme aligns sequences and outputs the best match and score.
Takes as input two files or if not files are inputed will default use two input files
This programme returns the highest alignments in a text file called 'Improved
fasta alignment.txt"""

__appname__ = '[Align sequences]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

import sys
import os   #Changes root directory

path = "../Data"   #sets variable of directory change 
os.chdir(path) #Changes the directory 

def parse_fasta(fastafile): #function named parse_fasta which defines the input as fastafile
    fastastr = ""  #Sets fastastr as an empty string 
    header = True #Includes a header 
    with open(fastafile, "r") as f: #opens input and reads in as f 
        for row in f:     #Goes through input file which is f 
            if header:  # Changes header to false so when the forloop goes through it ignores header
                header = False 
            else:  #If there is not a header the for loop strips the line and removes the newline character
                fastastr += row.strip("\n")
    return fastastr

if len(sys.argv) > 1:
    seq1 = parse_fasta(sys.argv[1]) #asigns the read in files to variables 
    seq2 = parse_fasta(sys.argv[2])
else:
    seq1 = parse_fasta("407228412.fasta") #If variables are not defined take the default 
    seq2 = parse_fasta("407228326.fasta")
  
# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest
 
l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"
    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = {} #Makes an empty dictionary to high score alignments 

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    my_best_align = "." * i + s2 # think about what this is doing!
    if z in my_best_score.keys():
        my_best_score[z].append(my_best_align) #if else statement taking the highest score and putting it in the dictinary
    else:
        my_best_score[z] = [my_best_align] #if new score is equal to high score add to dictionary 


vals = max(my_best_score.keys())

print("Sequences aligned!")


#dump <- bests, pickle_bests 
#pickle bests.close()

path = "../Code"
os.chdir(path)

f = open('../results/improved_fasta_alignment.txt', 'w+')
f.write ("Best Alignment: "+"\n")
for x in my_best_score[vals]:
    f.write(x)
f.write ("\n" + seq2 + "\n")
f.write ("Best Score: "+"\n" + str(vals))

f.close()


**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Sequences aligned!

**********************************************************************

Code ran without errors

Time consumed = 4.20538s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

""" Populates a dictionary to map order names to sets of taxa """

taxa_dic = {} #Empty dictionary 
set_order= set() #empty set 
for w in taxa: 
        set_order.add(w[1]) #Adds orders to set, as sets cant repeat words only four orders 

for y in set_order: 
        set_add = set()
        for i in taxa:
                if i[1]==y: #Goes through taxa list and if orders match output the species into dictionary 
                        set_add.add(i[0])
        taxa_dic[y]=set_add

print("Completed dictionary:", taxa_dic) #Prints completed dictionary 






        






**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Completed dictionary: {'Rodentia': {'Peromyscus crinitus', 'Cleithrionomys rutilus', 'Mus domesticus', 'Gerbillus henleyi'}, 'Afrosoricida': {'Microgale dobsoni', 'Microgale talazaci'}, 'Carnivora': {'Canis lupus', 'Arctocephalus gazella', 'Lyacon pictus'}, 'Chiroptera': {'Myotis lucifugus'}}

**********************************************************************

Code ran without errors

Time consumed = 0.02711s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
def createabug(x):
    y = x**4
    z = 0.
    import ipdb; pdb.set_trace()
    y = y/z
    return y 

createabug(25)
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 97.0

Output (only first 500 characters): 

**********************************************************************
[0;31m---------------------------------------------------------------------------[0m
[0;31mNameError[0m                                 Traceback (most recent call last)
[0;32m~/Documents/Teaching/IC_CMEE/2019-20/Coursework/StudentRepos/EmmaDeeks_EAD19/Week2/Code/debugme.py[0m in [0;36m<module>[0;34m()[0m
[1;32m      6[0m     [0;32mreturn[0m [0my[0m[0;34m[0m[0m
[1;32m      7[0m [0;34m[0m[0m
[0;32m----> 8[0;31m [0mcreateabug[0m[0;34m([0m[0;36m25[0m[0;34m)[0m[0;34m
**********************************************************************

Code ran without errors

Time consumed = 0.56656s

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
_a_global = 10 # a global variable

if _a_global >= 5:     #if this global variable is = or above 5
    _b_global = _a_global + 5 # also a global variable

def a_function():
    _a_global = 5 # a local variable
    
    if _a_global >= 5:
        _b_global = _a_global + 5 # also a local variable
    
    _a_local = 4
    
    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value of _b_global is ", _b_global)
    print("Inside the function, the value of _a_local is ", _a_local)
    
    return None

a_function()

print("Outside the function, the value of _a_global is ", _a_global)
print("Outside the function, the value of _b_global is ", _b_global)


###### Second code block 

_a_global = 10 #global variable

def a_function(): 
    _a_local = 4

    print("Inside the function, the value of _a_local is ", _a_local)
    print("Inside the function, the value of _a_global is ", _a_global)

    return None 

a_function()

print("Outside the function, the value of _a_global is", _a_global)

# Third code block 

_a_global = 10

print("Outside the function, the value of _a_global is", _a_global)

def a_function():
    global _a_global
    _a_global = 5
    _a_local = 4

    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value _a_local is ", _a_local)

    return None

a_function()

print("Outside the function, the value of _a_global is", _a_global)

#Fourth code block 
_a_global = 10

def a_function():

    def _a_function2():
        global _a_global
        _a_global = 20 
    
    print("Before calling a_function, balue of _a_global is", _a_global)

    _a_function2()

    print ("After calling _a_function2, value of _a_global is ", _a_global)
    
a_function()

print("The value of a_global in main workspace / namespace is ", _a_global)
**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 96.0

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value of _a_global is  5
Inside the function, the value of _b_global is  10
Inside the function, the value of _a_local is  4
Outside the function, the value of _a_global is  10
Outside the function, the value of _b_global is  15
Inside the function, the value of _a_local is  4
Inside the function, the value of _a_global is  10
Outside the function, the value of _a_global is 10
Outside the function, the value of _a_global is 10
Inside the function, the value of _a_global i
**********************************************************************

Code ran without errors

Time consumed = 0.03136s

======================================================================
Inspecting script file basic_io3.py...

File contents are:
**********************************************************************
#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use 
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 95.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io3.py", line 9, in <module>
    f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testp.p'

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 

"""Programme that tests mathmatical functions and outputs the results """

__appname__ = '[boilerplate]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__licence__ = "License for this code/program"

## imports ##
import sys # Module to interface our program with the operating system 

# What does each of foo_x do? 

def foo_1(x):
    return x ** 0.5 #Takes the square root of x

# If x is larger than y retur x and then return y underneth 
def foo_2(x,y):
    if x > y: 
        return x 
    return y 

# Orders the three numbers ans reutnrs the numbers ordered
def foo_3(x,y,z):
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z: 
        tmp = z
        z = y
        y = tmp
    return [x, y, z]

#one to x +1 and times them by themselves and outputs the results
def foo_4(x):
    result = 1
    for i in range(1, x + 1):
        result = result * i 
    return result 

# A recursrive function that calculates the factorial of x
def foo_5(x):
    if x ==1:
        return 1
    return x * foo_5(x - 1)

#Calculate the facorial of x in  different way 
def foo_6(x):
    facto = 1
    while x >= 1: 
        facto = facto * x
        x = x -1
    return facto


def main(argv):
    print("The square root of x is:", foo_1(3))
    print("The highest value is:", foo_2(5,7))
    print("Numbers ordered:", foo_3(3,9,8))
    print("Result:", foo_4(7))
    print("Factoral of value is:", foo_5(8))
    print("Factoral of value is:", foo_6(9))


if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Missing docstrings in one more functions!
.5 pt deducted per missing docstring

Current Points = 87.0

Output (only first 500 characters): 

**********************************************************************
The square root of x is: 1.7320508075688772
The highest value is: 7
Numbers ordered: [3, 8, 9]
Result: 5040
Factoral of value is: 40320
Factoral of value is: 362880

**********************************************************************

Code ran without errors

Time consumed = 0.02600s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by species 
# Hints: use the "print" command! You can use list comprehensions!
""" For loop that prints the latin name, common name and mass on seperate lines of a tuple of birds """


for i in birds: 
   print("The latin name is:",i[0]) #Indexes the list to extract the latin name, common name and mass
   print("The common name is:",i[1])
   print("The weight is:",i[2])**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
The latin name is: Passerculus sandwichensis
The common name is: Savannah sparrow
The weight is: 18.7
The latin name is: Delichon urbica
The common name is: House martin
The weight is: 19
The latin name is: Junco phaeonotus
The common name is: Yellow-eyed junco
The weight is: 19.5
The latin name is: Junco hyemalis
The common name is: Dark-eyed junco
The weight is: 19.6
The latin name is: Tachycineata bicolor
The common name is: Tree swallow
The weight is: 20.2

**********************************************************************

Code ran without errors

Time consumed = 0.02727s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

""" Uses List comprehensions to create three lists containing
latin names, common names and mean body masses for each species of birds """

#List comprehension for list with latin names 
first_words = {w[0] for w in birds}  #Comprehension that indexes the first line of the list
print(first_words)

#List comprehension for list with common names 
first_words = {w[1] for w in birds}
print(first_words)


#List comprehension for list with body mass 
first_words = {w[2] for w in birds}
print(first_words)


#For loop indexing a list of latin names from a list of birds
first_words = set()
for w in birds: 
    first_words.add(w[0])
print(first_words)

#For loop indexing a list of common names from a list of birds
first_words = set()
for w in birds: 
    first_words.add(w[1])
print(first_words)


#For loop indexing a list of body mass from a list of birds
first_words = set()
for w in birds: 
    first_words.add(w[2])
print(first_words)**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Tachycineata bicolor', 'Passerculus sandwichensis', 'Junco phaeonotus', 'Junco hyemalis', 'Delichon urbica'}
{'Tree swallow', 'Dark-eyed junco', 'House martin', 'Savannah sparrow', 'Yellow-eyed junco'}
{19.5, 19.6, 18.7, 19, 20.2}
{'Tachycineata bicolor', 'Passerculus sandwichensis', 'Junco phaeonotus', 'Junco hyemalis', 'Delichon urbica'}
{'Tree swallow', 'Dark-eyed junco', 'House martin', 'Savannah sparrow', 'Yellow-eyed junco'}
{19.5, 19.6, 18.7, 19, 20.2}

**********************************************************************

Code ran without errors

Time consumed = 0.02891s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
import csv
import sys
import doctest
import re

#Define function
def is_an_oak(name):
    
    """Tests the is_an_oak function to check output is correct. A function that outputs oak species from a given list 

    >>> is_an_oak('Fagus sylvatica')
    False

    >>> is_an_oak('quercus sylvatica')
    True

    >>> is_an_oak('quercs sylvatica')
    False

    """

    if re.match(r'\bquercus\b', name, re.IGNORECASE): 
        return True  #If input is exactly 'quercus' ignoring case than accept otherwise reject
    else:
        return False

def main(argv): 
    f = open('../Data/TestOaksData.csv','r')
    i =f.readline() 
    p = f.readlines()[0:] #Excludes header line of file
    g = open('../results/JustOaksData.csv','w')
    taxa = csv.reader(p)
    csvwrite = csv.writer(g)
    g.write(i) 
    oaks = set()
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    
      
    return 0   


if (__name__ == "__main__"):
    status = main(sys.argv)
    print(is_an_oak.__doc__) #Allows for doctests 
    doctest.testmod() 

**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!

Tests the is_an_oak function to check output is correct. A function that outputs oak species from a given list 

    >>> is_an_oak('Fagus sylvatica')
    False

    >>> is_an_oak('quercus sylvatica')
    True

    >>
**********************************************************************

Code ran without errors

Time consumed = 0.08912s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
## Finds just those taxa that are oak trees from a list of species 

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

#find all species that start with quercus 
def is_an_oak(name):
    return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set() #creates an empty object
for species in taxa: #calls upon the taxa list 
    if is_an_oak(species): 
        oaks_loops.add(species)
print(oaks_loops) #fills out species 

##Using list comprehensions
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops 
oaks_loops = set()
for species in taxa: 
    if is_an_oak(species): 
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions 
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 86.0

Output (only first 500 characters): 

**********************************************************************
{'Quercus petraea', 'Quercus cerris', 'Quercus robur'}
{'Quercus petraea', 'Quercus cerris', 'Quercus robur'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}

**********************************************************************

Code ran without errors

Time consumed = 0.04173s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
# FOR loops in python

#Prints 1 5 times 
for i in range(5):
    print(1)

#This creates a list and then just prints it in a list as k goes through the stuff in my_list
my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

# this for loop will go through summands and add each part of the list to total 0 and print it 
# It then adds cuitively 
total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loops in Python 

# Limit is 100 and z = 0, print z + 1 as z is now that variable 
z = 0 
while z < 100:
    z = z + 1
    print(z)

#will just print 'True' indefinately because nothing is making b False 
b = True 
while b: 
    print("GERONIMO! infinite loop! ctrl+c to stop!")
# ctrl + c to stop! 
**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 85.0

Output (only first 500 characters): 

**********************************************************************
1
1
1
1
1
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c
**********************************************************************

Code ran without errors

Time consumed = 10.35335s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Filename: using_name.py 

if __name__ == '__main__':
    print('This program is being run by itself')
else: 
    print('I am being imported from another module')**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 84.0

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.05980s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************

#!/usr/bin/env python3

"""This programme aligns sequences and outputs the best match and score"""

__appname__ = '[Align sequences]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

import sys
# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest
exec(open("../Data/sequences.csv").read(), globals()) #This executes a scripts and puts all the variables into the global scope.
                                                       #This means the rest of the programme can read in te variabels and use them 

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)        
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 
with open('../results/best_alignment.txt', 'w') as f: 
    print(my_best_align, file=f)
    print(s1, file=f)
    print("Best score:",my_best_score, file=f)

**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2
 
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4
 
.......-*-*-***-
.......CAATTCGGAT
ATCGCCGGATTACGGG
5
 
........------**
........CAATTCGGAT
ATCGCCGGATTACGGG
2
 
.........--*---*
.........CAATTCGGAT
ATCGCCGG
**********************************************************************

Code ran without errors

Time consumed = 0.06759s

======================================================================
Inspecting script file basic_io2.py...

File contents are:
**********************************************************************
#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file 
list_to_save = range(100)

f = open('../Sandbox/testout.txt', 'w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end 

f.close()**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 83.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.07861s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: " , str(sys.argv))**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 82.0

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.03010s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************

#!/usr/bin/env python3

"""This programme aligns sequences and outputs the best match and score"""

__appname__ = '[Align sequences]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

import sys
import os

path = "../Data"
os.chdir(path)

def parse_fasta(fastafile):
    fastastr = ""
    header = True
    with open(fastafile, "r") as f:
        for row in f: 
            if header: 
                header = False
            else: 
                fastastr += row.strip("\n")
    return fastastr

if len(sys.argv) > 1:
    seq1 = parse_fasta(sys.argv[1])
    seq2 = parse_fasta(sys.argv[2])
else:
    seq1 = parse_fasta("407228412.fasta")
    seq2 = parse_fasta("407228326.fasta")
  
# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest
 
l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"
    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 

print("Sequences aligned!")

path = "../Code"
os.chdir(path)

f = open('../results/best_fasta_alignment.txt', 'w+')
my_best_score = str(my_best_score)
f.write ("Best Alignment: ")
f.write (my_best_align)
f.write("\n")
f.write(seq2)
f.write ("Best Score: ")
f.write (my_best_score)
f.close()

**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Sequences aligned!

**********************************************************************

Code ran without errors

Time consumed = 4.57937s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 

"""Description of this program or application. You can use several lines"""

__appname__ = '[boilerplate]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__licence__ = "License for this code/program"

## imports ##
import sys # Module to interface our program with the operating system 

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return "%d is Even!" % x
    return "%d is Odd!" % x

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a variable.
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
          print("%d is not a prime: %d is a divisor" % (x, i)) 
          return False
    print("%d is a prime!" % x)
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
      if is_prime(i):
        allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

## constants ##


## functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.04449s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 

"""Some functions eemplifying the use of control statements"""

__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'

## imports ##
import sys # Module to interface our program with the operating system 
import doctest #Import the doctest module 

def even_or_odd(x=0): # if not specified, x should take value 0.
    """Find whether a number x is even or odd.

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided then the closest integer is used:
    >>> even_or_odd(3.2)
    '3 is Odd!'

    in case of negative numbers, the positive is taken: 
    >>> even_or_odd(-2)
    '-2 is Even!'

    """

    #Define function to be tested 
    if x % 2 == 0: #The conditional if
        return "%d is Even!" % x
    return "%d is Odd!" % x

#def main(argv):
#    print(even_or_odd(22))
#    print(even_or_odd(33))
#    return 0

# if (__name__ == "__main__"):
#     status = main(sys.argv)
############################################

doctest.testmod()**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.08872s

======================================================================
Inspecting script file basic_io1.py...

File contents are:
**********************************************************************
#############################
# FILE INPUT
#############################
# Open a file for reading
f = open('../sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 81.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io1.py", line 5, in <module>
    f = open('../sandbox/test.txt', 'r')
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/test.txt'

======================================================================
======================================================================
Finished running scripts

Ran into 2 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 81.0

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!