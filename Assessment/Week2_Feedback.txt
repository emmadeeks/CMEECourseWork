Starting weekly assessment for Emma, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 59.65 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, week4, Assessment, week3, week6, project, Week2, week9, week7, week5, .git, rda files, week8, error:output files

Found the following files in parent directory: edeeks_HPC_2019.zip, .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~
*.tmp
*.bbl
*.blg
*.pdf
*.aux
*.log
__pycache__
.DS_Store
.Rapp.history
<<<<<<< HEAD
.Rhistory
*.rda
*.sh.*
project/data 
project/data/Chagos_ALL_acoustic_2019.txt 
project/data/shape_files
. -size +50M
=======
.Rhistory
>>>>>>> 0d7590ae85f1493548f944ace5922e4c47068ab7
week8/code/.ipynb_checkpoints/FunRes-checkpoint.ipynb
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# CMEE Coursework Repository- README.md 


Files included: 
### week1: 
Unix Week:  Learnt the basics of UNIX including shell scripting, key commands such as grep and running functions. 
### week2: Focuses on the basics of Python; Topics covered include:
	- Basics of python syntax and data structures
	- Python's object-oriented features
	- How to write and run python code
	- Understand and implement python control flow tools
	- Learning to use the ipython environment 
	- Writing, debugging, using, and testing python functions 
	- Learning efficient numerical programming in python
	- Using regular expressions in python
	- Introduction to certain particularly useful python packages
	- Using python for building and modifying databases
	- Using python to run other, non-python tasks and code
	- Using python to patch together data analysis and/or numerical simulation work flows
### week3: 
Focuses on the basics of R as well as data exploration, management and visualisation; Topics covered include:
	- Basic R syntax and programming conventions assuming you have never set your eyes on R
	- Principles of data processing and exploration (including visualization) using R
	- Principles of clean and efficient programming using R
	- To generate publication quality graphics in R
	- To develop reproducible data analysis "work flows" so you (or anybody else) can run and re-run your analyses, graphics outputs and all, in R
	- To make R simulations more efficient using vectorization
	- To find and fix errors in R code using debugging
	- To make data wrangling and analyses more efficient and convenient using custom tools such as tidyr
	- Some additional tools and topics in R (accessing databases, building your own packages, etc.).
### week4
Stats week

### week5
GIS week
### week6
Miniproject week
### week7
Python II 
### week8
HPC week 

**********************************************************************

======================================================================
Looking for the weekly directories...

Found 9 weekly directories: Week1, Week2, week3, week4, week5, week6, week7, week8, week9

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox, results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# CMEE Coursework Repository- README.md 

## Week2 

Focuses on the basics of Python; Topics covered include:
- Basics of python syntax and data structures
- Python's object-oriented features
- How to write and run python code
- Understand and implement python control flow tools
- Learning to use the ipython environment 
- Writing, debugging, using, and testing python functions 
- Learning efficient numerical programming in python
- Using regular expressions in python
- Introduction to certain particularly useful python packages
- Using python for building and modifying databases
- Using python to run other, non-python tasks and code
- Using python to patch together data analysis and/or numerical simulation work flows

### Code:   Bold scripts are part of the practical coursework for week 2

| Script       | Function     | Input     | Output    |
| :------------- | :----------: | -----------: |-----------: |
|  **`align_seqs_better.py`** |  Runs alignments on files and inputs the highest alignments into a single text file as oppose to align_seqs_fatsa.py which outputs the last highest alignment the programme finds  |  Option to manually input 2 fasta files to be aligned or to have a default where there are no inputs  |  Text file with best alignment  |
|  **`align_seqs_fasta.py`** |  Same basic script as 'align_seqs.py' but aligns fasta files.  |  Option to manually input 2 fasta files to be aligned or to have a default where there are no inputs  | Text file with best aligment   |
|  **`align_seqs.py`** |  Converts the initial 'align_seqs.py' script to a programme that takes DNA sequences as an input from a single external file and saves the best alignment along with the score into a text file.   |  No manual input but in script takes single external csv file with DNA sequences   |  Text file with best alignment  |
|  ` basic_csv.py` |  Reads in the testcsv.csv file containing phylogeny information and appends a tuple with the name of a species.  |  No manual input but uses testcsv.csv from data directory |  bodymass.csv  |
|  `basic_io1.py` |  Returns the contents of 'test.txt' in different formats e.g. excludes second lines  |  No manual input but reads in test.txt  |  Formatted 'test.txt'  |
|  `basic_io2.py` |  Saves the elements of a list to a file and adds a new line when saving  |  No manual input but reads in test.txt  |  testout.txt file to sandbox directory   |
|  `basic_io3.py` |  Uses pickle to store an object from a dictionary before loading data again  |  No manual input but reads in testp.p  |  testp.p to sandbox directory with dictionary  |
|  `boilerplate.py` |  Example exercise on writing python programmes. Programme prints 'This is a boilerplate'). Also illustrates use of docstrings  |  No input  |  'This is a boilerplate'  |
|  **` cfexercises1.py`** |  Conditionals exercise containing 6 different foo_x calculation functions. Later modified to make a module that tests the foo_x functions as well as runs test arguments  |  No input  | The output of all 6 foo_x calculations   |
|  ` cfexercises2.py` |  A series of conditionals containing for and while loops   |  No input  |  Output of for a while loops  |
|  ` control_flow.py` |  Similar to boilerplate.py in structure as its a python programme but adds docstrings and a series of functions  |  No input  |  Outputs of all functions in script  |
|  `debugme.py` |  A script with a bug that was corrected with debugging  | Manual input not needed  | uses ipdb to trace bug |
|  **`dictionary.py`** |  Populates a dictionary to map order names to sets of taxa  |  No input  |  Completed dictionary  |
|  **` lc1.py`** |  List comprehensions compared to for loops   |  No input  | Three lists containing latin names, common names and mean body masses for each species of birds in a given list of birds   |
|  **` lc2.py`** |  Uses list comprehensions and for loops  |  No input  |  Creates a list of month and rainfall tuples when the amount of rain was; Greater than 100mm and Less than 50mm from a list of rainfall averages  |
|  `loops.py` |  A series of for and while loops   |  No input  |  output of "Geronimo! infinite loop!"  |
|  ** `oaks_debugme.py`** |  A script with a bug that was corrected with debugging  | File with tree species; **Note: must enter species name exactly**  |  File with only oak species found in list inputted |
|  `oaks.py` |  Uses for loops and list comprehensions to find taxa that are oak trees from a list of species.   |  No input  |  Oak species from list  |
|  ` scope.py` |  A collection of three blocks of code illustrating variable scope.  |  No input  |  Output of variable scope functions  |
|  ` sysargv.py` |  Exercise of the sys.argv module which contains the names of the argument variables in the current script  |  Script  |  Name, number of arguments and the arguments of the script  |
|  `test_control_flow.py` |  Function exemplifying the use of control elements  |  No input  |  Prints doctest  |
|  **` tuple.py`** |  Script to show use of tuples  |  No input  |  Prints the latin name, common name and mass of a list of birds on separate lines  |
|  ` using_name.py` |  An if else statement within a python programme |  No input  |  Prints whether the programme is being imported from another module of being run by itself  |


### Data: 
    
Files

	407228326.fasta: Input file for fasta exercise of align_seq practical   
	407228412.fasta: Input file for fasta exercise of align_seq practical
	TestOaksData.csv: Input file for oaks_debugme.py practical 
	sequences.csv: Input file for align_seqs practical part 2
	bodymass.csv: Test file for practicals
	testcsv.csv: Test input file for csv practical 


 #### Sandbox: 
 A practice directory for rough work and practice  
 
 ## Additional notes on packages required for scripts: 
- align_seqs_better.py: _Requires import sys and os_
- oaks_debugme.py: _Requires import csv, sys, doctest and re_
- sysargv.py: _Requires import sys_
- control_flow.py: _Requires import sys_
- align_seqs.py: _Requires import sys_
- align_seqs_fasta.py: _Requires import sys and os_
- basic_io3.py: _Requires import pickle_
- basic_csv.py: _Requires import csv_
- boilerplate.py: _Requires import sys_
- debugme.py: _Requires import ipdb_

    
    
    
    **********************************************************************

Found following files in results directory: JustOaksData.csv...

Found 23 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, align_seqs_better.py, dictionary.py, debugme.py, scope.py, basic_io3.py, cfexercises1.py, tuple.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, basic_io2.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py, basic_io1.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: lc2.py
#Desc: Uses list comprehensions and for loops
#Arguments: No input 
#Outputs: Creates a list of month and rainfall tuples when the amount of rain was; 
# Greater than 100mm and Less than 50mm from a list of rainfall averages
#Date: Oct 2019 

# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

""" Uses list comprehensions and for loops to create list of month, rainfall tuples when the
amount of rain was: 
Greater than 100mm 
Less than 50mm """

#List comprehension that returns months of rainfall when it was over or 
# equal to 100mm
x = set([i for i in rainfall if (i[1]) >= 100])
print(" Months of rainfall when it was over or equal to 100mm using comprehension \n", x, "\n")

# List comprehension that returns months of rainfall when it was under 50mm
x = set([i for i in rainfall if (i[1]) <= 50])
print(" Months of rainfall when it was under 50mm using comprehension\n", x, "\n")

# For loop that returns months of rainfall when it was over or 
# equal to 100mm
List_of_rain = []
for w in rainfall:
    if (w[1]) >= 100:
        List_of_rain.append(w)
print(" Months of rainfall when it was over or equal to 100mm using for loop \n", List_of_rain, "\n")

# For loop that returns months of rainfall when it was under 50mm
List_of_rain = []
for w in rainfall:
    if (w[1]) <= 50:
        List_of_rain.append(w)
for a in List_of_rain:
    print(" Months of rainfall when it was under 50mm using for loop \n", a, "\n")**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
 Months of rainfall when it was over or equal to 100mm using comprehension 
 {('JAN', 111.4), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2), ('FEB', 126.1)} 

 Months of rainfall when it was under 50mm using comprehension
 {('MAR', 49.9), ('SEP', 27.0)} 

 Months of rainfall when it was over or equal to 100mm using for loop 
 [('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)] 

 Months of rainfall when it was under 50mm using for loop 
 ('MAR', 49.9) 

 Months of ra
**********************************************************************

Code ran without errors

Time consumed = 0.02659s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: boilerplate.py
#Desc:  Example exercise on writing python programmes. Programme prints 'This is a boilerplate'). 
# Also illustrates use of docstrings
#Arguments: No input
#Outputs: 'This is a boilerplate'
#Date: Oct 2019 

"""This script illustrates how to writing python programmes using main arguments to import functions to modules """

__appname__ = '[boilerplate]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__licence__ = "License for this code/program"

## imports ##
import sys # Module to interface our program with the operating system 

## functions ##
def main(argv):  # this is defining a function 
    """ Main entry point of the program """ #Only appears in troubleshooting 
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0
# Makes file usable as a script as well as a importable module 
if __name__ == "__main__":   # Turning into a programme- executable externally 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)

#Import this module in python or ipython shell 
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.02782s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************

#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: basic_csv.py
#Desc:  Reads in the testcsv.csv file containing phylogeny information and appends a tuple with the name of a species.
#Arguments: No manual input but uses testcsv.csv from data directory
#Date: Oct 2019 
""" This script reads in the testcsv.csv file containing phylogeny information and appends a tuple with the name of a species."""
import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
f = open('../data/testcsv.csv','r')
csvread = csv.reader(f)
temp = []
# for loop that reads each row in the testcsv and prints the species in that row
for row in csvread: # 
    temp.append(tuple(row))  # Creates a tuple with species information 
    print(row) # Prints relevant information to computer 
    print("The species is", row[0]) #indexes specific row 

f.close()

# write a file containing only species name and Body mass
f = open('../data/testcsv.csv','r') # this 'r' means read the file
g = open('../data/bodymass.csv','w') # this 'w' means write the file

csvread = csv.reader(f) 
csvwrite = csv.writer(g) # asign these to a varianle 
for row in csvread:
    print(row)
    csvwrite.writerow([row[0], row[4]]) # indexes only species name and body mass from testcsv and appends it to the new file

f.close() # close files 
g.close()**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_csv.py", line 14, in <module>
    f = open('../data/testcsv.csv','r')
FileNotFoundError: [Errno 2] No such file or directory: '../data/testcsv.csv'

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: cfexercises2.py
#Desc:  A series of conditionals containing for and while loops
#Arguments: No input
#Outputs: Output of for a while loops
#Date: Oct 2019 

""" A series of conditionals containing for and while loops """

#for j in range of 12 dont print every 3 
for j in range(12):
    if j % 3 == 0: 
        print('prints every 3rd value out of 12')

# for the range in 15 if j is a multiple of 5 or 4 print 
for j in range(15):
    if j % 5 == 3:
        print('Multiple of 5')
    elif j % 4 == 3:
        print('Multiple of 4')

#Whilst z is not equal to 15 print hello in incredments of 3 
z = 0
while z != 15: 
    print('not equal to 15 yet!')
    z = z + 3

# makes z 12 and whil z is not equal to 100 if z is equal to 31 
# If z is equal to 31 print 
z = 12 
while z < 100:
    if z == 31:
        for k in range(7): 
            print('z is equal to 31 so print this 7 times')
    elif z == 18: 
        print('z is equal to 18!')
    z = z + 1**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
prints every 3rd value out of 12
prints every 3rd value out of 12
prints every 3rd value out of 12
prints every 3rd value out of 12
Multiple of 5
Multiple of 4
Multiple of 5
Multiple of 4
Multiple of 5
not equal to 15 yet!
not equal to 15 yet!
not equal to 15 yet!
not equal to 15 yet!
not equal to 15 yet!
z is equal to 18!
z is equal to 31 so print this 7 times
z is equal to 31 so print this 7 times
z is equal to 31 so print this 7 times
z is equal to 31 so print this 7 times
z is equal to 31 so 
**********************************************************************

Code ran without errors

Time consumed = 0.02716s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:
**********************************************************************

#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: align_seqs_better.py
#Desc:  Aligns sequences and outputs best match and score 
#saves the output into a text file called Improved_fasta_alignment.txt
#Arguments: Option to manually input 2 fasta files to be aligned or to have a default where there are no inputs
#Date: Oct 2019 

"""This programme aligns sequences and outputs the best match and score.
Takes as input two files or if not files are inputed will default use two input files
This programme returns the highest alignments in a text file called 'Improved
fasta alignment.txt. This script also takes into account any fasta file headings that might 
impact the score """

__author__ = 'Emma Deeks (ead19@ic.ac.uk)'


import sys
import os   #Changes root directory

path = "../data"   #sets variable of directory change 
os.chdir(path) #Changes the directory 

def parse_fasta(fastafile): #function named parse_fasta which defines the input as fastafile
   """ Defining parse_fasta input as fasta file, this function strips fasta files of their
     headers if they are found to have them in order for the alignment scores to be correct
    """
    fastastr = ""  #Sets fastastr as an empty string 
    header = True #Includes a header 
    """ Opens input """
    with open(fastafile, "r") as f: #opens input and reads in as f 
        for row in f:     #Goes through input file which is f 
            if header:  # Changes header to false so when the forloop goes through it ignores header
                header = False 
            else:  #If there is not a header the for loop strips the line and removes the newline character
                fastastr += row.strip("\n")
    return fastastr 

if len(sys.argv) > 1:
    seq1 = parse_fasta(sys.argv[1]) #asigns the read in files to variables 
    seq2 = parse_fasta(sys.argv[2]) # 
else:
    seq1 = parse_fasta("407228412.fasta") #If variables are not defined take the default 
    seq2 = parse_fasta("407228326.fasta")
  
# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest
 
l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """
    This function is calculating the scores by a series of if statements
    """
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"
    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = {} #Makes an empty dictionary to high score alignments 

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    my_best_align = "." * i + s2 # think about what this is doing!
    if z in my_best_score.keys():
        my_best_score[z].append(my_best_align) #if else statement taking the highest score and putting it in the dictinary
    else:
        my_best_score[z] = [my_best_align] #if new score is equal to high score add to dictionary 


vals = max(my_best_score.keys())

print("Sequences aligned!")


#dump <- bests, pickle_bests 
#pickle bests.close()

path = "../Code"
os.chdir(path)

# Writes a new text file into the results directory with the best sequence alignment 

f = open('../results/improved_fasta_alignment.txt', 'w+')
f.write ("Best Alignment: "+"\n") # Reads 'Best Alignment' then newspace
for x in my_best_score[vals]:
    f.write(x)
f.write ("\n" + seq2 + "\n") # adds in the first sequence
f.write ("Best Score: "+"\n" + str(vals)) # Adds in the second sequence 

f.close()


**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
  File "align_seqs_better.py", line 30
    fastastr = ""  #Sets fastastr as an empty string 
    ^
IndentationError: unexpected indent

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************

#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: dictionary.py
#Desc: Populates a dictionary to map order names to sets of taxa
#Arguments: No input 
#Outputs: Completed dictionary
#Date: Oct 2019 

""" Populates a dictionary to map order names to sets of taxa """

# Creates a dictionary of taxa 
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

""" Populates a dictionary to map order names to sets of taxa """

taxa_dic = {} #Empty dictionary 
set_order= set() #empty set 
for w in taxa: 
        set_order.add(w[1]) #Adds orders to set, as sets cant repeat words only four orders 

for y in set_order: 
        set_add = set()
        for i in taxa:
                if i[1]==y: #Goes through taxa list and if orders match output the species into dictionary 
                        set_add.add(i[0])
        taxa_dic[y]=set_add # Adds the sets to be added to the ordered dictionary then loops back throught he sets 

print("Completed dictionary:", taxa_dic) #Prints completed dictionary 






        






**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 98

Output (only first 500 characters): 

**********************************************************************
Completed dictionary: {'Afrosoricida': {'Microgale talazaci', 'Microgale dobsoni'}, 'Rodentia': {'Cleithrionomys rutilus', 'Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus'}, 'Chiroptera': {'Myotis lucifugus'}, 'Carnivora': {'Canis lupus', 'Arctocephalus gazella', 'Lyacon pictus'}}

**********************************************************************

Code ran without errors

Time consumed = 0.02640s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
#Author: Emma Deeks ead19@imperial.ac.uk
#Script: debugme.py
#Desc: A script with a bug that was corrected with debugging
#Arguments: No input but make sure %pdb is turned on before running script 
#Outputs: uses ipdb to trace bug
#Date: Oct 2019 

""" A script with a bug that needs to be corrected with debugging """

#### NOTE: FOR THIS SCRIPT TO SUCCESSFULLY RUN YOU MUST TURN ON %PDB 
#Defines a function that creates a bug 
def createabug(x):
    """ function that has a bug """
    y = x**4 # This is likely the bug as there are two ** 
    z = 0.
    import ipdb; pdb.set_trace()
    y = y/z
    return y 

createabug(25)
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 98

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "debugme.py", line 21, in <module>
    createabug(25)
  File "debugme.py", line 17, in createabug
    import ipdb; pdb.set_trace()
NameError: name 'pdb' is not defined

If you suspect this is an IPython bug, please report it at:
    https://github.com/ipython/ipython/issues
or send an email to the mailing list at ipython-dev@python.org

You can print a more detailed traceback right now with "%tb", or use "%debug"
to interactively debug it.

Extra-detailed tracebacks for bug-reporting purposes can be enabled via:
    %config Application.verbose_crash=True


======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: scope.py
#Desc: A collection of three blocks of code illustrating variable scope.
#Arguments: No input
#Outputs: Output of variable scope functions
#Date: Oct 2019 

""" A collection of three functions illustrating variable scope. This script has functions that assigns global and local functions in different ways  """

_a_global = 10 # a global variable

if _a_global >= 5:     #if this global variable is = or above 5
    _b_global = _a_global + 5 # also a global variable

def a_function():
    """ Function that sets a global variable and a local variable and prints these variables to screen """
    _a_global = 5 # a local variable
    
    if _a_global >= 5:
        _b_global = _a_global + 5 # also a local variable
    
    _a_local = 4
    
    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value of _b_global is ", _b_global)
    print("Inside the function, the value of _a_local is ", _a_local)
    
    return None

a_function()

print("Outside the function, the value of _a_global is ", _a_global)
print("Outside the function, the value of _b_global is ", _b_global)


###### Second code block 

_a_global = 10 #global variable

def a_function(): 
    """ Prints the local and global variables """ 
    _a_local = 4

    print("Inside the function, the value of _a_local is ", _a_local)
    print("Inside the function, the value of _a_global is ", _a_global)

    return None 

a_function()

print("Outside the function, the value of _a_global is", _a_global)

# Third code block 

_a_global = 10

print("Outside the function, the value of _a_global is", _a_global)

def a_function():
    """ Prints the local and global variables """ 
    global _a_global
    _a_global = 5
    _a_local = 4

    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value _a_local is ", _a_local)

    return None

a_function()

print("Outside the function, the value of _a_global is", _a_global)

#Fourth code block 
_a_global = 10

def a_function():
    """ Defines a function with a function of global and local variables """

    def _a_function2():
        global _a_global
        _a_global = 20 
    
    print("Before calling a_function, balue of _a_global is", _a_global)

    _a_function2()

    print ("After calling _a_function2, value of _a_global is ", _a_global)
    
a_function()

print("The value of a_global in main workspace / namespace is ", _a_global)
**********************************************************************

Testing scope.py...

scope.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value of _a_global is  5
Inside the function, the value of _b_global is  10
Inside the function, the value of _a_local is  4
Outside the function, the value of _a_global is  10
Outside the function, the value of _b_global is  15
Inside the function, the value of _a_local is  4
Inside the function, the value of _a_global is  10
Outside the function, the value of _a_global is 10
Outside the function, the value of _a_global is 10
Inside the function, the value of _a_global i
**********************************************************************

Code ran without errors

Time consumed = 0.02612s

======================================================================
Inspecting script file basic_io3.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3


#Author: Emma Deeks ead19@imperial.ac.uk
#Script: basic_i03.py
#Desc:  Uses pickle to store an object from a dictionary before loading data again
#Arguments: No manual input but reads in testp.p
#Outputs: testp.p to sandbox directory with dictionary
#Date: Oct 2019 

""" This script uses pickle to store an object from a dictionary before loading data again """

#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use 
my_dictionary = {"a key": 10, "another key": 11} # Creates a dictionary 

import pickle

f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f) # Illustrating use of pickle 
f.close()

## Load the data again
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io3.py", line 21, in <module>
    f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testp.p'

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 


#Author: Emma Deeks ead19@imperial.ac.uk
#Script: cfexercises1.py
#Desc:  Conditionals exercise containing 6 different foo_x calculation functions. 
# Later modified to make a module that tests the foo_x functions as well as runs test arguments
#Arguments: No input
#Outputs: The output of all 6 foo_x calculations
#Date: Oct 2019 

"""Programme that tests mathmatical functions and outputs the results, also imports these functions as modules  """

__appname__ = '[boilerplate]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__licence__ = "License for this code/program"

## imports ##
import sys # Module to interface our program with the operating system 

# What does each of foo_x do? 

def foo_1(x):
    """ Takes the square root of x """
    return x ** 0.5 #Takes the square root of x

# If x is larger than y retur x and then return y underneth 
def foo_2(x,y):
    """ Takes the highest value """
    if x > y: 
        return x 
    return y #The highest value 

# Orders the three numbers ans reutnrs the numbers ordered
def foo_3(x,y,z):
    """ Orders numbers and returns ordered numbers """
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z: 
        tmp = z
        z = y
        y = tmp
    return [x, y, z] # Numbers ordered

#one to x +1 and times them by themselves and outputs the results
def foo_4(x):
    """ one to x +1 and times them by themselves and outputs the results """
    result = 1
    for i in range(1, x + 1):
        result = result * i 
    return result 

# A recursrive function that calculates the factorial of x
def foo_5(x):
    """ Calculates the factoral of x """
    if x ==1:
        return 1
    return x * foo_5(x - 1) # Factoral of value is

#Calculate the facorial of x in  different way 
def foo_6(x):
    """ Calculates the factoral of x """
    facto = 1
    while x >= 1: 
        facto = facto * x
        x = x -1
    return facto # Factoral of value is


def main(argv):
    """ defines the main functiont that is to be returned when this module is run from 
    command line. Returns the outputs of the calculations from the predefined functions """
    print("The square root of x is:", foo_1(3))
    print("The highest value is:", foo_2(5,7))
    print("Numbers ordered:", foo_3(3,9,8))
    print("Result:", foo_4(7))
    print("Factoral of value is:", foo_5(8))
    print("Factoral of value is:", foo_6(9))

# Makes the main function/programme into a importable module that can be run from shell 
# main is the function that prints all the arguments 
if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************
The square root of x is: 1.7320508075688772
The highest value is: 7
Numbers ordered: [3, 8, 9]
Result: 5040
Factoral of value is: 40320
Factoral of value is: 362880

**********************************************************************

Code ran without errors

Time consumed = 0.02807s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: tuple.py
#Desc: Script to show use of tuples
#Arguments: No input
#Outputs: Prints the latin name, common name and mass of a list of birds on separate lines
#Date: Oct 2019 

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by species 
# Hints: use the "print" command! You can use list comprehensions!
""" For loop that prints the latin name, common name and mass on seperate lines of a tuple of birds """


for i in birds: 
   print("The latin name is:",i[0]) #Indexes the list to extract the latin name, common name and mass
   print("The common name is:",i[1])
   print("The weight is:",i[2], '\n')**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************
The latin name is: Passerculus sandwichensis
The common name is: Savannah sparrow
The weight is: 18.7 

The latin name is: Delichon urbica
The common name is: House martin
The weight is: 19 

The latin name is: Junco phaeonotus
The common name is: Yellow-eyed junco
The weight is: 19.5 

The latin name is: Junco hyemalis
The common name is: Dark-eyed junco
The weight is: 19.6 

The latin name is: Tachycineata bicolor
The common name is: Tree swallow
The weight is: 20.2 


**********************************************************************

Code ran without errors

Time consumed = 0.02839s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: lc1.py
#Desc: List comprehensions compared to for loops
#Arguments: No input 
#Outputs: Three lists containing latin names, common names and mean body masses for each species of birds in a given list of birds
#Date: Oct 2019 


# Creates a list of bird species, common name and body mass
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

""" Uses List comprehensions to create three lists containing
latin names, common names and mean body masses for each species of birds """

#List comprehension for list with latin names 
first_words = {w[0] for w in birds}  #Comprehension that indexes the first line of the list
print("The Latin names of the birds using comprehensions: \n", first_words, "\n")

#List comprehension for list with common names 
first_words = {w[1] for w in birds} # common name is second in list 
print("The common names of the birds using comprehensions:\n ", first_words, "\n")


#List comprehension for list with body mass 
first_words = {w[2] for w in birds} # The body mass is third in the list 
print("The body mass of the birds using comprehensions: \n", first_words, "\n")


#For loop indexing a list of latin names from a list of birds
first_words = set() # This is to be appended with the desired latin names, common names and body mass 
# This is then printed to screen after for loop has run through index of list 
for w in birds: 
    first_words.add(w[0])
print("The Latin names of the birds using for loops: \n", first_words, "\n")

#For loop indexing a list of common names from a list of birds
first_words = set()
for w in birds: 
    first_words.add(w[1])
print("The common names of the birds using for loops: \n", first_words, "\n")


#For loop indexing a list of body mass from a list of birds
first_words = set() #Creates empty set that can be appened to in for loop 
for w in birds: 
    first_words.add(w[2])
print("The body mass of the birds using for loops: \n", first_words, "\n")**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************
The Latin names of the birds using comprehensions: 
 {'Passerculus sandwichensis', 'Junco hyemalis', 'Delichon urbica', 'Junco phaeonotus', 'Tachycineata bicolor'} 

The common names of the birds using comprehensions:
  {'House martin', 'Tree swallow', 'Dark-eyed junco', 'Savannah sparrow', 'Yellow-eyed junco'} 

The body mass of the birds using comprehensions: 
 {19.5, 19.6, 18.7, 19, 20.2} 

The Latin names of the birds using for loops: 
 {'Passerculus sandwichensis', 'Junco hyemalis', 'Delicho
**********************************************************************

Code ran without errors

Time consumed = 0.03415s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: oaks_debugme.py
#Desc: A script with a bug that was corrected with debugging
#Arguments: File with tree species; Note: must enter species name exactly
#Outputs: File with only oak species found in list inputted
#Date: Oct 2019 

""" A script with a bug that was corrected with debugging """

import csv
import sys
import doctest
import re

#Define function
def is_an_oak(name):
    
    """Tests the is_an_oak function to check output is correct. A function that outputs oak species from a given list 

    >>> is_an_oak('Fagus sylvatica')
    False

    >>> is_an_oak('quercus sylvatica')
    True

    >>> is_an_oak('quercs sylvatica')
    False

    """

    if re.match(r'\bquercus\b', name, re.IGNORECASE): 
        return True  #If input is exactly 'quercus' ignoring case than accept otherwise reject
    else:
        return False

def main(argv): 
    """ Main entry point of the program """ 
    f = open('../data/TestOaksData.csv','r')
    i =f.readline() 
    p = f.readlines()[0:] #Excludes header line of file
    g = open('../results/JustOaksData.csv','w')
    taxa = csv.reader(p)
    csvwrite = csv.writer(g)
    g.write(i) 
    oaks = set()
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    
      
    return 0   


if (__name__ == "__main__"):
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    print(is_an_oak.__doc__) #Allows for doctests 
    doctest.testmod() 

**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "oaks_debugme.py", line 61, in <module>
    status = main(sys.argv)
  File "oaks_debugme.py", line 40, in main
    f = open('../data/TestOaksData.csv','r')
FileNotFoundError: [Errno 2] No such file or directory: '../data/TestOaksData.csv'

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: oaks.py
#Desc: Uses for loops and list comprehensions to find taxa that are oak trees from a list of species.
#Arguments: No input
#Outputs: Oak species from list
#Date: Oct 2019 

""" Uses for loops and list comprehensions to find taxa that are oak trees from a list of species. """

## Finds just those taxa that are oak trees from a list of species 

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

#find all species that start with quercus 
def is_an_oak(name):
    """ Find all the species that start with the name quercus """
    return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set() #creates an empty object
for species in taxa: #calls upon the taxa list 
    if is_an_oak(species): # calls the function and if it i add the the empty set 
        oaks_loops.add(species)
print("List of oaks found in taxa: \n", oaks_loops) #fills out species 

##Using list comprehensions
oaks_lc = set([species for species in taxa if is_an_oak(species)]) 
print("List of oaks found in taxa: \n", oaks_lc)

##Get names in UPPER CASE using for loops 
oaks_loops = set()
for species in taxa: 
    if is_an_oak(species): 
        oaks_loops.add(species.upper())
print("List of oaks found in taxa: \n", oaks_loops)

##Get names in UPPER CASE using list comprehensions 
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print("List of oaks found in taxa: \n", oaks_lc)**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************
List of oaks found in taxa: 
 {'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
List of oaks found in taxa: 
 {'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
List of oaks found in taxa: 
 {'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}
List of oaks found in taxa: 
 {'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}

**********************************************************************

Code ran without errors

Time consumed = 0.02720s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: loops.py
#Desc: A series of for and while loops
#Arguments: No input 
#Outputs: output of "Geronimo! infinite loop!"
#Date: Oct 2019 

""" A series of for and while loops which outputs a infinate loop of Geronimo! """

# FOR loops in python

#Prints 1 5 times 
for i in range(5):
    print(1)

#This creates a list and then just prints it in a list as k goes through the stuff in my_list
my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

# this for loop will go through summands and add each part of the list to total 0 and print it 
# It then adds cuitively 
total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loops in Python 

# Limit is 100 and z = 0, print z + 1 as z is now that variable 
z = 0 
while z < 100:
    z = z + 1
    print(z)

#will just print 'True' indefinately because nothing is making b False 
b = True 
while b: 
    print("GERONIMO! infinite loop! ctrl+c to stop!")
# ctrl + c to stop! 
**********************************************************************

Testing loops.py...

loops.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 97.5

Output (only first 500 characters): 

**********************************************************************
1
1
1
1
1
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c
**********************************************************************

Code ran without errors

Time consumed = 10.33956s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: using_name.py
#Desc: An if else statement within a python programme
#Arguments: No input
#Outputs: Prints whether the programme is being imported from another module of being run by itself
#Date: Oct 2019  

""" an if else statement within a python programme that states whether 
a python programme has been imported or being run by itself """

if __name__ == '__main__':
    """ If the programme is the main argument then it will print that its being 
    run by itself but if it is not the main then it is imported """ 
    
    print('This program is being run by itself')
else: 
    print('I am being imported from another module')**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 95.5

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.06343s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************

#!/usr/bin/env python3
#Author: Emma Deeks ead19@imperial.ac.uk
#Script: align_seqs.py
#Desc:  Converts the initial 'align_seqs.py' script to a programme that 
# takes DNA sequences as an input from a single external file and saves the best alignment along with the score into a text file.
#Arguments: No manual input but in script takes single external csv file with DNA sequences
#Date: Oct 2019 
"""This programme aligns sequences and outputs the best match and score"""

__appname__ = '[Align sequences]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

import sys
# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest
exec(open("../data/sequences.csv").read(), globals()) #This executes a scripts and puts all the variables into the global scope.
                                                       #This means the rest of the programme can read in te variabels and use them 

l1 = len(seq1)  # data wrangling to get the sequences into a usable format with the longest sequence being s1 
l2 = len(seq2) # s2 is always sequence that is compared so is shortest 
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """
    This function is calculating the scores by a series of if statements
    """
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)        
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 
with open('../results/best_alignment.txt', 'w') as f:  # Writes text file 
    print(my_best_align, file=f)
    print(s1, file=f)
    print("Best score:",my_best_score, file=f) 

**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 95.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "align_seqs.py", line 19, in <module>
    exec(open("../data/sequences.csv").read(), globals()) #This executes a scripts and puts all the variables into the global scope.
FileNotFoundError: [Errno 2] No such file or directory: '../data/sequences.csv'

======================================================================
Inspecting script file basic_io2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: basic_i02.py
#Desc:  Saves a list of numbers to a text file with newline 
#Arguments: No manual input but reads in test.txt
#Outputs: testout.txt file to sandbox directory
#Date: Oct 2019 

""" This script saves a list of numbers to a text file with newlines """ 

# Save the elements of a list to a file 
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close() # Saves a list of numbers to a text file with newline **********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 95.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io2.py", line 15, in <module>
    f = open('../sandbox/testout.txt','w')
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testout.txt'

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: sysargv.py
#Desc: Exercise of the sys.argv module which contains the names of the argument variables in the current script
#Arguments: No input
#Outputs: Name, number of arguments and the arguments of the script
#Date: Oct 2019 

""" Exercise of the sys.argv module which contains the names of the argument variables in the current script and prints them in different ways """

import sys
print("This is the name of the script: ", sys.argv[0]) # Prints acttal system argument 
print("Number of arguments: ", len(sys.argv)) #prints the length of the system argument 
print("The arguments are: " , str(sys.argv)) # Turns system arguments into strings **********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 95.5

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.02591s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************

#!/usr/bin/env python3

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: align_seqs_fasta.py
#Desc:  Same basic script as 'align_seqs.py' but aligns fasta files.
#Arguments: Option to manually input 2 fasta files to be aligned or to have a default where there are no inputs
#Date: Oct 2019 

"""This programme aligns sequences and outputs the best match and score, It takes as input fasta files.
This script also accounts for any headers that fasta files might have """

__appname__ = '[Align sequences]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

import sys
import os

path = "../data" # this creates a variable called path which goes into the data directory 
os.chdir(path) # This changes the directory to the data directory 

def parse_fasta(fastafile): #This defines a function to strip fasta files of headers
     """ Defining parse_fasta input as fasta file, this function strips fasta files of their
     headers if they are found to have them in order for the alignment scores to be correct
    """
    fastastr = "" #creates empty variable
    header = True # defines that there is a header
    with open(fastafile, "r") as f: # reads in fasta file as f
        for row in f:  #goes through each row in file 
            if header: # if there is no header then do nothing
                header = False
            else: 
                fastastr += row.strip("\n") #if there is a header strip it and leave a newline
    return fastastr #this empty bariable becomes the ammended fasta fie

if len(sys.argv) > 1: #if there are more than one sys.arguments
    seq1 = parse_fasta(sys.argv[1]) #assigns these system arguments as variables
    seq2 = parse_fasta(sys.argv[2]) #Both inputs have become seq1 and 2 
else:
    seq1 = parse_fasta("407228412.fasta") # if no system arguments are put in then take these two files 
    seq2 = parse_fasta("407228326.fasta")  # as defaults 
  
# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest
 
l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """
    This function is calculating the scores by a series of if statements
    """
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"
    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 

print("Sequences aligned!")

path = "../code" #Changing back to the code directory 
os.chdir(path)

f = open('../results/best_fasta_alignment.txt', 'w+') #Write a new text file 
my_best_score = str(my_best_score)  # Converts my_best_score to a string
f.write ("Best Alignment: ")
f.write (my_best_align) #Alignement 1 
f.write("\n") # New line 
f.write(seq2) # Alignment 2 
f.write ("Best Score: ")
f.write (my_best_score) # Score 
f.close()

**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 95.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
  File "align_seqs_fasta.py", line 28
    fastastr = "" #creates empty variable
                                        ^
IndentationError: unindent does not match any outer indentation level

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: control_flow.py
#Desc: Similar to boilerplate.py in structure as its a python programme but adds docstrings and a series of functions
#Arguments: No input
#Outputs: Outputs of all functions in script
#Date: Oct 2019 

""" Similar to boilerplate.py in structure as its a python programme but adds docstrings and a series of functions """

__appname__ = '[control_flow.py]'
__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'
__licence__ = "License for this code/program"

## imports ##
import sys # Module to interface our program with the operating system 

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Finds whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return "%d is Even!" % x
    return "%d is Odd!" % x

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a variable.
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
          print("%d is not a prime: %d is a divisor" % (x, i)) 
          return False
    print("%d is a prime!" % x)
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
      if is_prime(i):
        allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    """ Main entry point of the program that returns output of all the functions """
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

## functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 95.5

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.02552s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 

#Author: Emma Deeks ead19@imperial.ac.uk
#Script: test_control_flow.py
#Desc: Exercise of the sys.argv module which contains the names of the argument variables in the current script
#Arguments: No input
#Outputs: Prints doctests
#Date: Oct 2019 

"""Some functions exemplifying the use of control statements"""

__author__ = 'Emma Deeks (ead19@ic.ac.uk)'
__version__ = '0.0.1'

## imports ##
import sys # Module to interface our program with the operating system 
import doctest #Import the doctest module 

def even_or_odd(x=0): # if not specified, x should take value 0.
    """Find whether a number x is even or odd. These are doctests 

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided then the closest integer is used:
    >>> even_or_odd(3.2)
    '3 is Odd!'

    in case of negative numbers, the positive is taken: 
    >>> even_or_odd(-2)
    '-2 is Even!'

    """

    #Define function to be tested 
    if x % 2 == 0: #The conditional if
        return "%d is Even!" % x
    return "%d is Odd!" % x

# In this function it sets the main module and gives the defined function inputs to test 
def main(argv):
    """ Main entry point of the program """ 
    print(even_or_odd(22))
    print(even_or_odd(33))
    return 0

if (__name__ == "__main__"):
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    print(even_or_odd.__doc__) #Allows for doctests 
    doctest.testmod() 
############################################

**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 95.5

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
Find whether a number x is even or odd. These are doctests 

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided then the closest integer is used:
    >>> even_or_odd(3.2)
    '3 is Odd!'

    in case of negative numbers, the positive is taken: 
    >>> even_or_odd(-2)
    '-2 is Even!'

    

**********************************************************************

Code ran without errors

Time consumed = 0.06094s

======================================================================
Inspecting script file basic_io1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3


#Author: Emma Deeks ead19@imperial.ac.uk
#Script: basic_i01.py
#Desc:  Returns the contents of 'test.txt' in different formats e.g. excludes second lines
#Arguments: No manual input but reads in test.txt
#Date: Oct 2019 


""" This script returns the contents of 'test.txt' in different formats e.g. excludes second lines, 
Illustrates the use of for loops and writing files """

# Open a file for reading
f = open('../sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:  #Prints the lines in the file to a screen
    print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0: #This is only printing lines with information on 
        print(line)

f.close()**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 95.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io1.py", line 15, in <module>
    f = open('../sandbox/test.txt', 'r')
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/test.txt'

======================================================================
======================================================================
Finished running scripts

Ran into 9 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 95.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!