source get_Tree_Height.R trees
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
#For loop that uses two inputs to the for loop which is the two things you are subsetting
#t is the variable for the data once its been subsetted once, and predator lifestage is assigned to i
#and then subsetted again and type of feeding interaction is assigned to j
#a linear regression is run on the subsette ddata
#p is a variable then then puts the outputs of the vector in order
#p then goes into the re made dataframe.
for(i in levels(MyDF$Predator.lifestage)){
for(j in levels(MyDF$Type.of.feeding.interaction)){
for(h in levels(MyDF$Location)){
t = subset(MyDF, MyDF$Predator.lifestage == i)
t = subset(t, t$Type.of.feeding.interaction == j)
t = subset(t, t$Location == h)
if (dim(t)[1] > 0){
mylm <- summary(lm(Predator.mass~Prey.mass, data = t))
p <- c(i,j,mylm$coefficients[1], mylm$coefficients[2], mylm$adj.r.squared, mylm$fstatistic[1], mylm$coefficients[8])
Orange = rbind(Orange, p)
}
}
}
}
Orange = as.data.frame(matrix(nrow = 1, ncol = 7))
#For loop that uses two inputs to the for loop which is the two things you are subsetting
#t is the variable for the data once its been subsetted once, and predator lifestage is assigned to i
#and then subsetted again and type of feeding interaction is assigned to j
#a linear regression is run on the subsette ddata
#p is a variable then then puts the outputs of the vector in order
#p then goes into the re made dataframe.
for(i in levels(MyDF$Predator.lifestage)){
for(j in levels(MyDF$Type.of.feeding.interaction)){
for(h in levels(MyDF$Location)){
t = subset(MyDF, MyDF$Predator.lifestage == i)
t = subset(t, t$Type.of.feeding.interaction == j)
t = subset(t, t$Location == h)
if (dim(t)[1] > 0){
mylm <- summary(lm(Predator.mass~Prey.mass, data = t))
p <- c(i,j,mylm$coefficients[1], mylm$coefficients[2], mylm$adj.r.squared, mylm$fstatistic[1], mylm$coefficients[8])
Orange = rbind(Orange, p)
}
}
}
}
#takes off certain rows and then writes csv to a file
Orange <- Orange[-c(1, 17),]
colnames(Orange) <- c("Predator_Lifestage", "Feeding_interaction", "Intercept", "Slope", "Adjusted_R_sequared", "FStat", "Pvalue")
Orange = as.data.frame(matrix(nrow = 1, ncol = 8))
#For loop that uses two inputs to the for loop which is the two things you are subsetting
#t is the variable for the data once its been subsetted once, and predator lifestage is assigned to i
#and then subsetted again and type of feeding interaction is assigned to j
#a linear regression is run on the subsette ddata
#p is a variable then then puts the outputs of the vector in order
#p then goes into the re made dataframe.
for(i in levels(MyDF$Predator.lifestage)){
for(j in levels(MyDF$Type.of.feeding.interaction)){
for(h in levels(MyDF$Location)){
t = subset(MyDF, MyDF$Predator.lifestage == i)
t = subset(t, t$Type.of.feeding.interaction == j)
t = subset(t, t$Location == h)
if (dim(t)[1] > 0){
mylm <- summary(lm(Predator.mass~Prey.mass, data = t))
p <- c(i,j,h,mylm$coefficients[1], mylm$coefficients[2], mylm$adj.r.squared, mylm$fstatistic[1], mylm$coefficients[8])
Orange = rbind(Orange, p)
}
}
}
}
#takes off certain rows and then writes csv to a file
Orange <- Orange[-c(1, 17),]
colnames(Orange) <- c("Predator_Lifestage", "Feeding_interaction", "Location", "Intercept", "Slope", "Adjusted_R_sequared", "FStat", "Pvalue")
write.csv(Orange, file = "../results/PP_Regress_Results.csv")
rm(list=ls()) #Clear global environment
#Set working directory
setwd("/Users/emmadeeks/Desktop/CMEECourseWork/week6/code")
#Read in the bears data
bears <- read.csv("../data/bears.csv", header = FALSE, colClasses = "character", stringsAsFactors = FALSE)
#1. Identify which positions are SNPs (polymorphic, meaning that they have more than one allele)
m <- c() #Create empty vector
for (i in 1:ncol(bears)){ #For i in each column of the data set
if(length(unique(bears[,i])) > 1)  m <- c(m,i) #If the length of each unique value in each column is greateer than one
} #Put unique values/position of unique value into a dataframe
m
count.fields(m[1,])
count.fields(m[1])
count.fields(m)
table(m)
table(bears)
dcast(bears, V1~V2, value.var="var", fun.aggregate=sum)
library(reshape2)
dcast(bears, V1~V2, value.var="var", fun.aggregate=sum)
m
bears$m
bears[,30]
bears[,31]
for (i in 1:m){
new <- bears[,i]
}
new
table(new)
for (i in 1:m){
new <- bears[,i]
freq <-table(new)
}
m
freq
for (i in 1:m){
freq <-c(freq,table(new)
}
table()
dcast(bears, V1~V2, value.var="var", fun.aggregate=sum)
bears$m
for (i in 1:m){
new <- bears[,i]
freq <-c(freq,table(new))
}
freq
for (i in 1:m){
new <- c(new, bears[,i])
freq <-c(freq,table(new))
}
freq
for (i in 1:m){
new <- bears[,i])
freq <- table(new)
}
for (i in 1:m){
new <- bears[,i]
freq <- table(new)
}
freq
for (i in 1:nrow(m)){
new <- bears[,i]
freq <- table(new)
}
freq
for (i in 1:ncol(m)){
new <- bears[,i]
freq <- table(new)
}
freq
for (i in 1:length(m)){
new <- bears[,i]
freq <- table(new)
}
freq
for (i in 1:seq_along(m)){
new <- bears[,i]
freq <- table(new)
}
freq
m
for (i in m){
new <- bears[,i]
freq <- table(new)
}
freq
for (i in m){
new <- bears[,i]
freq <- (freq,table(new))
}
for (i in m){
new <- bears[,i]
freq <- c(freq, table(new))
}
freq
new
aggregate(list(names(unlist(new))), FUN=mean)
### again we can loop over each SNP and easily calculate allele frequencies
frequencies <- c()
for (i in 1:ncol(data)) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i, "with alleles", alleles)
### we have to make a decision on which allele to consider to calculate its frequency;
### for instance, after we sort them, we can pick the second one (but the choice at this stage is arbitrary)
### frequency (of the second allele)
freq <- length(which(data[,i]==alleles[2])) / nrow(data)
cat(" and allele frequency of the second allele", freq)
frequencies <- c(frequencies, freq)
}
### again we can loop over each SNP and easily calculate allele frequencies
frequencies <- c()
for (i in 1:ncol(bears)) {
### alleles in this SNPs
alleles <- sort(unique(bears[,i]))
cat("\nSNP", i, "with alleles", alleles)
### we have to make a decision on which allele to consider to calculate its frequency;
### for instance, after we sort them, we can pick the second one (but the choice at this stage is arbitrary)
### frequency (of the second allele)
freq <- length(which(bears[,i]==alleles[2])) / nrow(bears)
cat(" and allele frequency of the second allele", freq)
frequencies <- c(frequencies, freq)
}
### we can plot is as a histogram
hist(frequencies)
### or simply the frequencies at each position
plot(frequencies, type="h")
### this works to retain the indexes of SNPs; a smartest way would not involve doing a loop but using `apply` functions
cat("\nNumber of SNPs is", length(snps))
### this works to retain the indexes of SNPs; a smartest way would not involve doing a loop but using `apply` functions
cat("\nNumber of SNPs is", length(m))
### reduce the data set
data <- data[,m]
### reduce the data set
data <- bears[,m]
dim(data)
### SNPs are positions where you observed more than one allele
### the easiest thing is to loop over all sites and record the ones with two alleles
snps <- c()
for (i in 1:ncol(bears)) {
if (length(unique(bears[,i]))==2) snps <- c(snps, i)
}
### this works to retain the indexes of SNPs; a smartest way would not involve doing a loop but using `apply` functions
cat("\nNumber of SNPs is", length(snps))
### reduce the data set
data <- data[,snps]
### reduce the data set
data <- bears[,snps]
dim(data)
data
### again we can loop over each SNP and easily calculate allele frequencies
frequencies <- c()
for (i in 1:ncol()) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i, "with alleles", alleles)
### we have to make a decision on which allele to consider to calculate its frequency;
### for instance, after we sort them, we can pick the second one (but the choice at this stage is arbitrary)
### frequency (of the second allele)
freq <- length(which(data[,i]==alleles[2])) / nrow(data)
cat(" and allele frequency of the second allele", freq)
frequencies <- c(frequencies, freq)
}
### again we can loop over each SNP and easily calculate allele frequencies
frequencies <- c()
for (i in 1:ncol(data)) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i, "with alleles", alleles)
### we have to make a decision on which allele to consider to calculate its frequency;
### for instance, after we sort them, we can pick the second one (but the choice at this stage is arbitrary)
### frequency (of the second allele)
freq <- length(which(data[,i]==alleles[2])) / nrow(data)
cat(" and allele frequency of the second allele", freq)
frequencies <- c(frequencies, freq)
}
### we can plot is as a histogram
hist(frequencies)
### or simply the frequencies at each position
plot(frequencies, type="h")
#1. Identify which positions are SNPs (polymorphic, meaning that they have more than one allele)
snps <- c() #Create empty vector
for (i in 1:ncol(bears)){ #For i in each column of the data set
if(length(unique(bears[,i])) > 1)  snps <- c(snps,i) #If the length of each unique value in each column is greateer than one
} #Put unique values/position of unique value into a dataframe
### this works to retain the indexes of SNPs; a smartest way would not involve doing a loop but using `apply` functions
cat("\nNumber of SNPs is", length(snps))
### reduce the data set
data <- bears[,snps]
dim(data)
### again, we can loop over each SNPs and each individual and print the genotype frequencies
nsamples <- 20
for (i in 1:ncol(data)) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i, "with alleles", alleles)
### as before, I can choose one allele as "reference"
### genotypes are Allele1/Allele1 Allele1/Allele2 Allele2/Allele2
genotype_counts <- c(0, 0, 0)
for (j in 1:nsamples) {
### indexes of genotypes for individual j
genotype_index <- c( (j*2)-1, (j*2) )
### count the Allele2 instances
genotype <- length(which(data[genotype_index, i]==alleles[2])) + 1
### increase the counter for the corresponding genotype
genotype_counts[genotype] <- genotype_counts[genotype] + 1
}
cat(" and genotype frequencies", genotype_counts)
}
rm(list=ls()) #Clear global environment
rm(list=ls()) #Clear global environment
rm(list=ls()) #Clear global environment
rm(list=ls()) #Clear global environment
#Set working directory
setwd("/Users/emmadeeks/Desktop/CMEECourseWork/week6/code")
#Read in the bears data
bears <- read.csv("../data/bears.csv", header = FALSE, colClasses = "character", stringsAsFactors = FALSE)
#1. Identify which positions are SNPs (polymorphic, meaning that they have more than one allele)
snps <- c() #Create empty vector
for (i in 1:ncol(bears)){ #For i in each column of the data set
if(length(unique(bears[,i])) > 1)  snps <- c(snps,i) #If the length of each unique value in each column is greateer than one
} #Put unique values/position of unique value into a dataframe
### this works to retain the indexes of SNPs; a smartest way would not involve doing a loop but using `apply` functions
cat("\nNumber of SNPs is", length(snps))
### reduce the data set
data <- bears[,snps]
dim(data)
### again we can loop over each SNP and easily calculate allele frequencies
frequencies <- c()
for (i in 1:ncol(data)) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i, "with alleles", alleles)
### we have to make a decision on which allele to consider to calculate its frequency;
### for instance, after we sort them, we can pick the second one (but the choice at this stage is arbitrary)
### frequency (of the second allele)
freq <- length(which(data[,i]==alleles[2])) / nrow(data)
cat(" and allele frequency of the second allele", freq)
frequencies <- c(frequencies, freq)
}
### we can plot is as a histogram
hist(frequencies)
### or simply the frequencies at each position
plot(frequencies, type="h")
### again, we can loop over each SNPs and each individual and print the genotype frequencies
nsamples <- 20
for (i in 1:ncol(data)) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i, "with alleles", alleles)
### as before, I can choose one allele as "reference"
### genotypes are Allele1/Allele1 Allele1/Allele2 Allele2/Allele2
genotype_counts <- c(0, 0, 0)
for (j in 1:nsamples) {
### indexes of genotypes for individual j
genotype_index <- c( (j*2)-1, (j*2) )
### count the Allele2 instances
genotype <- length(which(data[genotype_index, i]==alleles[2])) + 1
### increase the counter for the corresponding genotype
genotype_counts[genotype] <- genotype_counts[genotype] + 1
}
cat(" and genotype frequencies", genotype_counts)
}
### we can reuse the previous code and easily calculate the heterozygosity
nsamples <- 20
for (i in 1:ncol(data)) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i, "with alleles", alleles)
### as before, I can choose one allele as "reference"
### genotypes are Allele1/Allele1 Allele1/Allele2 Allele2/Allele2
genotype_counts <- c(0, 0, 0)
for (j in 1:nsamples) {
### indexes of genotypes for individual j
genotype_index <- c( (j*2)-1, (j*2) )
### count the Allele2 instances
genotype <- length(which(data[genotype_index, i]==alleles[2])) + 1
### increase the counter for the corresponding genotype
genotype_counts[genotype] <- genotype_counts[genotype] + 1
}
cat(" and heterozygosity", genotype_counts[2]/nsamples, "and homozygosity", 1-genotype_counts[2]/nsamples)
}
nonHWE <- c() # to store indexes of SNPs deviating from HWE
nsamples <- 20
for (i in 1:ncol(data)) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i)
### as before, I can choose one allele as "reference"
### frequency (of the second allele)
freq <- length(which(data[,i]==alleles[2])) / nrow(data)
### from the frequency, I can calculate the expected genotype counts under HWE
genotype_counts_expected <- c( (1-freq)^2, 2*freq*(1-freq), freq^2) * nsamples
### genotypes are Allele1/Allele1 Allele1/Allele2 Allele2/Allele2
genotype_counts <- c(0, 0, 0)
for (j in 1:nsamples) {
### indexes of genotypes for individual j
genotype_index <- c( (j*2)-1, (j*2) )
### count the Allele2 instances
genotype <- length(which(data[genotype_index, i]==alleles[2])) + 1
### increase the counter for the corresponding genotype
genotype_counts[genotype] <- genotype_counts[genotype] + 1
}
### test for HWE: calculate chi^2 statistic
chi <- sum( (genotype_counts_expected - genotype_counts)^2 / genotype_counts_expected )
## pvalue
pv <- 1 - pchisq(chi, df=1)
cat("with pvalue for test against HWE", pv)
## retain SNPs with pvalue<0.05
if (pv < 0.05) nonHWE <- c(nonHWE, i)
}
### assuming we ran the code for point 5, we already have the SNPs deviating
F <- c()
nsamples <- 20
for (i in nonHWE) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i)
### as before, I can choose one allele as "reference"
### frequency (of the second allele)
freq <- length(which(data[,i]==alleles[2])) / nrow(data)
### from the frequency, I can calculate the expected genotype counts under HWE
genotype_counts_expected <- c( (1-freq)^2, 2*freq*(1-freq), freq^2) * nsamples
### genotypes are Allele1/Allele1 Allele1/Allele2 Allele2/Allele2
genotype_counts <- c(0, 0, 0)
for (j in 1:nsamples) {
### indexes of genotypes for individual j
genotype_index <- c( (j*2)-1, (j*2) )
### count the Allele2 instances
genotype <- length(which(data[genotype_index, i]==alleles[2])) + 1
### increase the counter for the corresponding genotype
genotype_counts[genotype] <- genotype_counts[genotype] + 1
}
### calculate inbreeding coefficient
inbreeding <- ( 2*freq*(1-freq) - (genotype_counts[2]/nsamples) ) / ( 2*freq*(1-freq) )
F <- c(F, inbreeding)
cat(" with inbreeding coefficient", inbreeding)
}
### plot
hist(F)
plot(F, type="h")
for (i in m){
new <- bears[,i]
freq <- c(freq, table(new))
}
data_w <- read.csv("../western_banded_gecko.csv", stringsAsFactors=F, header=F, colClasses=rep("character", len))
setwd("/Users/emmadeeks/Desktop/CMEECourseWork/week6/code")
data_w <- read.csv("../data/western_banded_gecko.csv", stringsAsFactors=F, header=F, colClasses=rep("character", len))
head(data_w)
data_w <- read.csv("../data/western_banded_gecko.csv", stringsAsFactors=F, header=F, colClasses=rep("character", len))
len <- 20000
data_w <- read.csv("../data/western_banded_gecko.csv", stringsAsFactors=F, header=F, colClasses=rep("character", len))
dim(data_w)
data_b <- read.csv("../bent-toed_gecko.csv", stringsAsFactors=F, header=F, colClasses=rep("character", len))
dim(data_b)
data_b <- read.csv("../data/bent-toed_gecko.csv", stringsAsFactors=F, header=F, colClasses=rep("character", len))
dim(data_b)
data_l <- read.csv("../data/leopard_gecko.csv", stringsAsFactors=F, header=F, colClasses=rep("character", len))
dim(data_l)
head(data_w)
?colClasses
?read.csv
data_w <- read.csv("../data/western_banded_gecko.csv", stringsAsFactors=F, header=F, colClasses=rep("character"))
dim(data_w)
data_b <- read.csv("../data/bent-toed_gecko.csv", stringsAsFactors=F, header=F, colClasses=rep("character"))
dim(data_b)
data_l <- read.csv("../data/leopard_gecko.csv", stringsAsFactors=F, header=F, colClasses=rep("character"))
dim(data_l)
for (i in 1:ncol(data_b)) {
### you need to discard SNPs within each species
if (length(unique(data_b[,i]))==1 & length(unique(data_l[,i]))==1) {
sites_total <- sites_total + 1
### if different, then it's a divergent site
if (data_b[1,i] != data_l[1,i]) sites_divergent <- sites_divergent + 1
}
}
sites_total <- 0
sites_divergent <- 0
for (i in 1:ncol(data_b)) {
### you need to discard SNPs within each species
if (length(unique(data_b[,i]))==1 & length(unique(data_l[,i]))==1) {
sites_total <- sites_total + 1
### if different, then it's a divergent site
if (data_b[1,i] != data_l[1,i]) sites_divergent <- sites_divergent + 1
}
}
length(unique(data_b[,i]))==1
unique(data_b[,4])
unique(data_b[,3])
unique(data_b[,70])
data_b[1,4]
data_l[1,4]
sites_divergent
sites_total
### divergence rate
#To recap, sites total is every site which and divergent is just those that diverge
#calculate rate by dividing these
div_rate_BL <- sites_divergent / sites_total
div_rate_BL
sites_total <- 0
sites_divergent <- 0
for (i in 1:ncol(data_w)) {
### you need to discard SNPs within each species
if (length(unique(data_w[,i]))==1 & length(unique(data_l[,i]))==1) {
sites_total <- sites_total + 1
### if different, then it's a divergent site
if (data_w[1,i] != data_l[1,i]) sites_divergent <- sites_divergent + 1
}
}
### divergence rate
div_rate_WL <- sites_divergent / sites_total
div_rate_WL
for (i in 1:ncol(data_w)) {
### you need to discard SNPs within each species
if (length(unique(data_w[,i]))==1 & length(unique(data_b[,i]))==1) {
sites_total <- sites_total + 1
### if different, then it's a divergent site
if (data_w[1,i] != data_b[1,i]) sites_divergent <- sites_divergent + 1
}
}
### divergence rate
div_rate_WB <- sites_divergent / sites_total
div_rate_BL
div_rate_WB
div_rate_WL
## estimate mutation rate per site per year
mut_rate <- div_rate_BL / (2 * 5e7)
mut_rate
## estimate divergence time
div_time <- div_rate_WB / (2 * mut_rate)
cat("\nThe two species have a divergence time of", div_time, "years.")
cat("\nThe most likely species tree is L:(W:B).")
data_N <- as.matrix(read.csv("../killer_whale_North.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric"))
data_N <- as.matrix(read.csv("../killer_whale_North.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric"))
data_S <- as.matrix(read.csv("../killer_whale_South.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric")))
data_N <- as.matrix(read.csv("../data/killer_whale_North.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric"))
data_N <- as.matrix(read.csv("../data/killer_whale_North.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric")))
dim(data_N)
data_N <- as.matrix(read.csv("../data/killer_whale_North.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric")))
dim(data_N)
data_S <- as.matrix(read.csv("../data/killer_whale_South.csv", stringsAsFactors=F, header=F, colClasses=rep("numeric")))
dim(data_S)
